// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const addBook = `-- name: AddBook :exec
INSERT into BOOKS(book_id, title, image_url, librivox_url, genre, author, summary, language, total_duration) values($1,$2,$3,$4,$5,$6,$7,$8,$9)
`

type AddBookParams struct {
	BookID        uuid.UUID      `json:"book_id"`
	Title         sql.NullString `json:"title"`
	ImageUrl      sql.NullString `json:"image_url"`
	LibrivoxUrl   sql.NullString `json:"librivox_url"`
	Genre         sql.NullString `json:"genre"`
	Author        sql.NullString `json:"author"`
	Summary       sql.NullString `json:"summary"`
	Language      sql.NullString `json:"language"`
	TotalDuration sql.NullString `json:"total_duration"`
}

func (q *Queries) AddBook(ctx context.Context, arg AddBookParams) error {
	_, err := q.exec(ctx, q.addBookStmt, addBook,
		arg.BookID,
		arg.Title,
		arg.ImageUrl,
		arg.LibrivoxUrl,
		arg.Genre,
		arg.Author,
		arg.Summary,
		arg.Language,
		arg.TotalDuration,
	)
	return err
}

const fetchBooksByGenre = `-- name: FetchBooksByGenre :many
SELECT book_id, title, image_url, librivox_url, genre, author, summary, language, total_duration FROM BOOKS where genre like '%' || $1 || '%' ORDER BY title
`

func (q *Queries) FetchBooksByGenre(ctx context.Context, dollar_1 sql.NullString) ([]Book, error) {
	rows, err := q.query(ctx, q.fetchBooksByGenreStmt, fetchBooksByGenre, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.ImageUrl,
			&i.LibrivoxUrl,
			&i.Genre,
			&i.Author,
			&i.Summary,
			&i.Language,
			&i.TotalDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchBooksByTitleAndAuthor = `-- name: FetchBooksByTitleAndAuthor :many
SELECT book_id, title, image_url, librivox_url, genre, author, summary, language, total_duration FROM BOOKS where title LIKE '%' || $1 || '%' and author LIKE '%' || $2 || '%' ORDER BY title
`

type FetchBooksByTitleAndAuthorParams struct {
	Column1 sql.NullString `json:"column_1"`
	Column2 sql.NullString `json:"column_2"`
}

func (q *Queries) FetchBooksByTitleAndAuthor(ctx context.Context, arg FetchBooksByTitleAndAuthorParams) ([]Book, error) {
	rows, err := q.query(ctx, q.fetchBooksByTitleAndAuthorStmt, fetchBooksByTitleAndAuthor, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.ImageUrl,
			&i.LibrivoxUrl,
			&i.Genre,
			&i.Author,
			&i.Summary,
			&i.Language,
			&i.TotalDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBooks = `-- name: GetAllBooks :many
SELECT book_id, title, image_url, librivox_url, genre, author, summary, language, total_duration FROM BOOKS
`

func (q *Queries) GetAllBooks(ctx context.Context) ([]Book, error) {
	rows, err := q.query(ctx, q.getAllBooksStmt, getAllBooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.BookID,
			&i.Title,
			&i.ImageUrl,
			&i.LibrivoxUrl,
			&i.Genre,
			&i.Author,
			&i.Summary,
			&i.Language,
			&i.TotalDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookByID = `-- name: GetBookByID :one
SELECT book_id, title, image_url, librivox_url, genre, author, summary, language, total_duration FROM  BOOKS where book_id=$1
`

func (q *Queries) GetBookByID(ctx context.Context, bookID uuid.UUID) (Book, error) {
	row := q.queryRow(ctx, q.getBookByIDStmt, getBookByID, bookID)
	var i Book
	err := row.Scan(
		&i.BookID,
		&i.Title,
		&i.ImageUrl,
		&i.LibrivoxUrl,
		&i.Genre,
		&i.Author,
		&i.Summary,
		&i.Language,
		&i.TotalDuration,
	)
	return i, err
}

const getSeekPosition = `-- name: GetSeekPosition :one
SELECT seek_position from PLAYSTATE where user_id=$1 AND book_chapter=$2
`

type GetSeekPositionParams struct {
	UserID      uuid.UUID      `json:"user_id"`
	BookChapter sql.NullString `json:"book_chapter"`
}

func (q *Queries) GetSeekPosition(ctx context.Context, arg GetSeekPositionParams) (sql.NullInt32, error) {
	row := q.queryRow(ctx, q.getSeekPositionStmt, getSeekPosition, arg.UserID, arg.BookChapter)
	var seek_position sql.NullInt32
	err := row.Scan(&seek_position)
	return seek_position, err
}

const updateSeekPosition = `-- name: UpdateSeekPosition :exec
INSERT INTO PLAYSTATE(user_id, book_chapter, seek_position) values ($1, $2, $3)
ON CONFLICT (user_id, book_chapter) DO UPDATE SET seek_position = $3
`

type UpdateSeekPositionParams struct {
	UserID       uuid.UUID      `json:"user_id"`
	BookChapter  sql.NullString `json:"book_chapter"`
	SeekPosition sql.NullInt32  `json:"seek_position"`
}

func (q *Queries) UpdateSeekPosition(ctx context.Context, arg UpdateSeekPositionParams) error {
	_, err := q.exec(ctx, q.updateSeekPositionStmt, updateSeekPosition, arg.UserID, arg.BookChapter, arg.SeekPosition)
	return err
}
